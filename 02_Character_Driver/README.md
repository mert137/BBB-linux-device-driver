<h1> Character Driver </h1>

- Character driver accesses data from the device sequentially. i.e., byte by byte (like a stream of characters) not as a chunk of data.
- Sophisticated buffering strategies are usually not involved in char drivers. Because when you write 1 byte, it directly goes to the device without any intermediate buffering, delayed write back, dirty buffer management.
- Char devices: sensors, RTC, keyboard, serial port, parallel port,...etc.

## 1. Scenario
- Write a character driver to deal with a pseudo character device.
- The pseudo-device is a memory buffer of some size (in case 512 byte).
- The driver what you write must support reading/writing/seeking to this device .
- Test the driver functionality by running user-level command such as echo, dd, cat and by writing user lever programs.
- Write application running on user-level for test the driver functionality.

## 2. Connection establishment between device file access and the driver

### Step 1: Create device number
- The device number is a combination of major and minor numbers.
- In Linux kernel, `dev_t` *(typedef of u32)* type is used to represent the device number.
- Out of **32 bits**, **12 bits** to store **major number** and remaining **20 bits** to store **minor number**
- You can use the below macros to extract major and minor parts of `dev_t` type variable:
```text
#include <linux/kdev_t.h>

dev_t device_number;
int minor = MINOR(device_number);
int major = MAJOR(device_number);
```
- If you have major and minor numbers, use the below macro to turn them into `dev_t` type device number:
```text
MKDEV(int major, int minor);
```
**- Dynamically register a range of char device numbers**
```text
int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)
```
+ **dev_t \*dev**: Output parameter for first assigned number 
+ **unsigned baseminor**: first of the requested range of minor numbers
+ **unsigned count**: number of minor numbers required
+ **const char \*name**: name of the associated device or driver

**Example:**
```text
#include <linux/fs.h>

dev_t device_number;
alloc_chrdev_region(&device_number, 0, 1, "pcd_devices");
```

### Step 2: Create device files
**- Initialize a cdev_init structure**
```text
void cdev_init (struct cdev *cdev, const struct file_operations *fops);
```
+ **struct cdev \*cdev**: the structure to initialize
+ **const struct file_operations \*fops**: the file operations for this device (open, read, write, lseek, mmap, flush,...)
+ `THIS_MODULE` is a macro which resolves in to "pointer to a struct module variable which corresponds to our current module"

**- cdev_add - add a char device to the system**
```text
int cdev_add (struct cdev *p, dev_t dev, unsigned count);
```
+ **struct cdev \*p**: the `cdev` structure for the device
+ **dev_t dev**: the first device number for which this device is responsible
+ **unsigned count**: the number of consecutive minor numbers corresponding to this device

**Example:**
```text
#include <linux/cdev.h>

struct cdev pcd_cdev;
struct file_operations pcd_fops = {
    .open       = pcd_open,
    .write      = pcd_write,
    .read       = pcd_read,
    .release    = pcd_release,
    .llseek     = pcd_lseek,
    .owner      = THIS_MODULE
};

cdev_init(&pcd_cdev, &pcd_fops);
cdev_add(&pcd_cdev, device_number, 1);
```

### Step 3: Make a char device registration with the VFS
- In Linux, you can create a device file dynamically (on demand), i.e you need not manually create the device files under `/dev` directory to access your hardware.
- User-level program such as `udevd` can populate `/dev` directory with device files dynamically.
- `udev` program listens to the `uevents` generated by hot plug events or kernel modules. When `udev` receives the `uevents`, it scans the subdirectories of `/sys/class` looking for the **"dev"** files to create device files.
- For each such **'dev'** file, which represents a combination of major and minor number for a device, the `udev` program creates a corresponding device file in `/dev` directory.
<p align="center"> <img width="850" src="https://user-images.githubusercontent.com/32474027/94242763-8068b100-ff51-11ea-9faa-69cfdfd77c73.png" /> </p>

**- Create and register a class with sysfs**
```text
struct class *class_create(struct module *owner, const char *name)
```
+ **struct module \*owner**: pointer to the module that is to “own” this struct class
+ **const char \*name**: pointer to a string for the name of this class

**- Populates the sysfs class you created in previous step with device numbers and device names**
```text
struct device * device_create (struct class *class, struct device *parent, dev_t devt, const char *fmt, ...);
```
+ **struct class \*class**: pointer to the struct class that this device should be registered to
+ **struct device \*parent**: pointer to the parent struct device of this new device, if any
+ **dev_t devt**: the dev_t for the char device to be added
+ **const char \*fmt**: string for the device's name
+ ...: variable arguments

**Example:**
```text
#include <linux/device.h>

struct class *class_pcd;
struct device *device_pcd;

class_pcd = class_create(THIS_MODULE, "pcd_class");
device_pcd = device_create(class_pcd, NULL, device_number, NULL, "pcd");
```

### Step 4: Implement the driver’s file operation methods for open, read, write, lseek.
- In this character driver we will give support to handle the below user level system call (open/close/read/write/llseek)


#### Summary
- When device file gets created
1. Create device file using `udev`
2. Inode object gets created in memory and inode's `i_rdev` field is initialized with device number
3. Inode object's `i_fop` field is set to dummy default file operations (def_chr_fops)

- When user process executes open system call
1. User invokes open system call on the device file
2. File object gets created
3. Inode's `i_fop` gets copied to file object's `f_op` (dummy default file operations of char device file)
4. Open function of dummy default file operations gets called (chrdev_open)
5. Inode object's `i_cdev` field is initialized with `cdev` which you added during `cdev_add` (lookup happens using inode-> i_rdev field)
6. `inode->cdev->fops` (this is a real file operations of your driver) gets copied to `file->f_op`
7. `file->f_op->open` method gets called (read open method of your driver)
